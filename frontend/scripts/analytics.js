// Advanced Analytics and Export Functionality
class AnalyticsManager {
    constructor(app) {
        this.app = app;
        this.exportFormats = ['pdf', 'excel', 'csv', 'json'];
    }

    // Data Export Functions
    async exportData(format) {
        try {
            this.app.showNotification(`Preparing ${format.toUpperCase()} export...`);
            
            const data = this.prepareExportData();
            
            switch (format) {
                case 'pdf':
                    await this.exportToPDF(data);
                    break;
                case 'excel':
                    await this.exportToExcel(data);
                    break;
                case 'csv':
                    await this.exportToCSV(data);
                    break;
                case 'json':
                    await this.exportToJSON(data);
                    break;
                default:
                    throw new Error('Unsupported export format');
            }
            
            this.app.showNotification(`${format.toUpperCase()} export completed successfully!`);
            
        } catch (error) {
            this.app.showNotification(`Export failed: ${error.message}`);
        }
    }

    prepareExportData() {
        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        
        return {
            exportDate: now.toISOString(),
            dateRange: `${thirtyDaysAgo.toLocaleDateString()} - ${now.toLocaleDateString()}`,
            meetings: this.app.meetings.map(meeting => ({
                ...meeting,
                teamMemberName: this.app.teamMembers.find(tm => tm.id === meeting.teamMemberId)?.name || 'Unknown',
                completedQuestionsCount: meeting.standardQuestions?.filter(q => q.completed).length || 0,
                completedDiscussionPointsCount: meeting.discussionPoints?.filter(p => p.completed).length || 0
            })),
            teamMembers: this.app.teamMembers,
            tasks: this.app.tasks,
            analytics: this.generateAnalytics(),
            roadmapItems: this.app.roadmapManager?.roadmapItems || []
        };
    }

    async exportToPDF(data) {
        // In a real implementation, this would use a library like jsPDF or server-side PDF generation
        const pdfContent = this.generatePDFContent(data);
        
        // Simulate PDF generation
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Create downloadable content
        const blob = new Blob([pdfContent], { type: 'application/pdf' });
        this.downloadFile(blob, '1on1-manager-report.pdf');
    }

    generatePDFContent(data) {
        return `
            1-on-1 Manager Report
            Generated: ${new Date(data.exportDate).toLocaleString()}
            Date Range: ${data.dateRange}
            
            MEETINGS SUMMARY
            ================
            Total Meetings: ${data.meetings.length}
            Completed Meetings: ${data.meetings.filter(m => m.completed).length}
            Average Duration: ${this.calculateAverageDuration(data.meetings)} minutes
            
            TEAM PERFORMANCE
            ================
            Team Members: ${data.teamMembers.length}
            Active Members: ${data.teamMembers.filter(tm => tm.status === 'active').length}
            
            ACTION ITEMS
            ============
            Total Tasks: ${data.tasks.length}
            Completed Tasks: ${data.tasks.filter(t => t.completed).length}
            Completion Rate: ${Math.round((data.tasks.filter(t => t.completed).length / data.tasks.length) * 100)}%
            
            ANALYTICS
            =========
            Meeting Frequency: ${data.analytics.meetingFrequency}
            Engagement Score: ${data.analytics.engagementScore}%
            Goal Achievement: ${data.analytics.goalAchievement}%
            
            This report was generated by 1-on-1 Manager
        `;
    }

    async exportToExcel(data) {
        // Simulate Excel generation
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        const excelData = this.generateExcelData(data);
        const blob = new Blob([excelData], { type: 'application/vnd.ms-excel' });
        this.downloadFile(blob, '1on1-manager-data.xls');
    }

    generateExcelData(data) {
        // Generate tab-separated values that Excel can import
        let excel = 'MEETINGS\n';
        excel += 'Date\tTeam Member\tDuration\tCompleted Questions\tCompleted Discussion Points\tNotes\n';
        
        data.meetings.forEach(meeting => {
            const date = new Date(meeting.date).toLocaleDateString();
            const duration = meeting.duration ? Math.floor(meeting.duration / 60) : 'N/A';
            const notes = (meeting.notes || '').replace(/\n/g, ' ').replace(/\t/g, ' ');
            
            excel += `${date}\t${meeting.teamMemberName}\t${duration}\t${meeting.completedQuestionsCount}\t${meeting.completedDiscussionPointsCount}\t${notes}\n`;
        });
        
        excel += '\n\nTEAM MEMBERS\n';
        excel += 'Name\tPosition\tEmail\tStatus\tJoined Date\n';
        
        data.teamMembers.forEach(member => {
            excel += `${member.name}\t${member.position}\t${member.email}\t${member.status}\t${member.joinedAt || 'N/A'}\n`;
        });
        
        excel += '\n\nACTION ITEMS\n';
        excel += 'Description\tAssignee\tDue Date\tCompleted\tCreated Date\n';
        
        data.tasks.forEach(task => {
            const assignee = task.assigneeId === 'manager' ? 'Manager' : 'Direct Report';
            const dueDate = task.dueDate || 'N/A';
            const completed = task.completed ? 'Yes' : 'No';
            const createdDate = task.createdAt ? new Date(task.createdAt).toLocaleDateString() : 'N/A';
            
            excel += `${task.description}\t${assignee}\t${dueDate}\t${completed}\t${createdDate}\n`;
        });
        
        return excel;
    }

    async exportToCSV(data) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const csvData = this.generateCSVData(data);
        const blob = new Blob([csvData], { type: 'text/csv' });
        this.downloadFile(blob, '1on1-manager-meetings.csv');
    }

    generateCSVData(data) {
        let csv = 'Date,Team Member,Duration (min),Completed Questions,Completed Discussion Points,Status,Notes\n';
        
        data.meetings.forEach(meeting => {
            const date = new Date(meeting.date).toLocaleDateString();
            const duration = meeting.duration ? Math.floor(meeting.duration / 60) : '';
            const status = meeting.completed ? 'Completed' : 'Scheduled';
            const notes = (meeting.notes || '').replace(/"/g, '""').replace(/\n/g, ' ');
            
            csv += `"${date}","${meeting.teamMemberName}","${duration}","${meeting.completedQuestionsCount}","${meeting.completedDiscussionPointsCount}","${status}","${notes}"\n`;
        });
        
        return csv;
    }

    async exportToJSON(data) {
        await new Promise(resolve => setTimeout(resolve, 500));
        
        const jsonData = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonData], { type: 'application/json' });
        this.downloadFile(blob, '1on1-manager-backup.json');
    }

    downloadFile(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // Analytics Generation
    generateAnalytics() {
        const meetings = this.app.meetings;
        const tasks = this.app.tasks;
        const teamMembers = this.app.teamMembers;
        
        return {
            meetingFrequency: this.calculateMeetingFrequency(meetings),
            engagementScore: this.calculateEngagementScore(meetings),
            goalAchievement: this.calculateGoalAchievement(tasks),
            teamPerformance: this.analyzeTeamPerformance(meetings, teamMembers),
            trends: this.analyzeTrends(meetings),
            actionItemAnalysis: this.analyzeActionItems(tasks)
        };
    }

    calculateMeetingFrequency(meetings) {
        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const recentMeetings = meetings.filter(m => new Date(m.date) >= thirtyDaysAgo);
        
        return Math.round((recentMeetings.length / 30) * 7); // Meetings per week
    }

    calculateEngagementScore(meetings) {
        if (meetings.length === 0) return 0;
        
        const totalPossibleQuestions = meetings.length * 3; // 3 standard questions per meeting
        const completedQuestions = meetings.reduce((sum, meeting) => 
            sum + (meeting.standardQuestions?.filter(q => q.completed).length || 0), 0);
        
        const questionScore = (completedQuestions / totalPossibleQuestions) * 100;
        
        const meetingsWithNotes = meetings.filter(m => m.notes && m.notes.trim().length > 0).length;
        const notesScore = (meetingsWithNotes / meetings.length) * 100;
        
        return Math.round((questionScore + notesScore) / 2);
    }

    calculateGoalAchievement(tasks) {
        if (tasks.length === 0) return 0;
        
        const completedTasks = tasks.filter(t => t.completed).length;
        return Math.round((completedTasks / tasks.length) * 100);
    }

    analyzeTeamPerformance(meetings, teamMembers) {
        return teamMembers.map(member => {
            const memberMeetings = meetings.filter(m => m.teamMemberId === member.id);
            const completedMeetings = memberMeetings.filter(m => m.completed).length;
            const avgQuestionsCompleted = memberMeetings.length > 0 ? 
                memberMeetings.reduce((sum, m) => sum + (m.standardQuestions?.filter(q => q.completed).length || 0), 0) / memberMeetings.length : 0;
            
            return {
                memberId: member.id,
                name: member.name,
                totalMeetings: memberMeetings.length,
                completedMeetings,
                engagementScore: Math.round(avgQuestionsCompleted * 33.33), // Out of 100
                lastMeeting: memberMeetings.length > 0 ? 
                    Math.max(...memberMeetings.map(m => new Date(m.date).getTime())) : null
            };
        });
    }

    analyzeTrends(meetings) {
        const monthlyData = {};
        
        meetings.forEach(meeting => {
            const date = new Date(meeting.date);
            const monthKey = `${date.getFullYear()}-${date.getMonth() + 1}`;
            
            if (!monthlyData[monthKey]) {
                monthlyData[monthKey] = {
                    month: monthKey,
                    meetingCount: 0,
                    completedMeetings: 0,
                    totalDuration: 0,
                    avgEngagement: 0
                };
            }
            
            monthlyData[monthKey].meetingCount++;
            if (meeting.completed) {
                monthlyData[monthKey].completedMeetings++;
            }
            if (meeting.duration) {
                monthlyData[monthKey].totalDuration += meeting.duration;
            }
        });
        
        return Object.values(monthlyData).sort((a, b) => a.month.localeCompare(b.month));
    }

    analyzeActionItems(tasks) {
        const analysis = {
            total: tasks.length,
            completed: tasks.filter(t => t.completed).length,
            overdue: 0,
            byAssignee: {
                manager: tasks.filter(t => t.assigneeId === 'manager').length,
                directReport: tasks.filter(t => t.assigneeId === 'direct-report').length
            }
        };
        
        // Count overdue tasks
        const now = new Date();
        analysis.overdue = tasks.filter(t => 
            !t.completed && t.dueDate && new Date(t.dueDate) < now
        ).length;
        
        return analysis;
    }

    calculateAverageDuration(meetings) {
        const completedMeetings = meetings.filter(m => m.completed && m.duration);
        if (completedMeetings.length === 0) return 0;
        
        const totalDuration = completedMeetings.reduce((sum, m) => sum + m.duration, 0);
        return Math.round(totalDuration / completedMeetings.length / 60); // Convert to minutes
    }

    // Advanced Search Functionality
    performAdvancedSearch(query, filters = {}) {
        const results = {
            meetings: [],
            teamMembers: [],
            tasks: [],
            roadmapItems: []
        };
        
        const searchTerm = query.toLowerCase();
        
        // Search meetings
        results.meetings = this.app.meetings.filter(meeting => {
            const teamMember = this.app.teamMembers.find(tm => tm.id === meeting.teamMemberId);
            const matchesSearch = !searchTerm || 
                (teamMember?.name.toLowerCase().includes(searchTerm)) ||
                (meeting.notes?.toLowerCase().includes(searchTerm)) ||
                (meeting.discussionPoints?.some(p => p.text.toLowerCase().includes(searchTerm)));
            
            const matchesDateRange = this.matchesDateRange(meeting.date, filters.dateRange);
            const matchesMember = !filters.teamMember || meeting.teamMemberId == filters.teamMember;
            const matchesStatus = !filters.status || 
                (filters.status === 'completed' && meeting.completed) ||
                (filters.status === 'scheduled' && !meeting.completed);
            
            return matchesSearch && matchesDateRange && matchesMember && matchesStatus;
        });
        
        // Search team members
        if (!filters.searchType || filters.searchType === 'all' || filters.searchType === 'members') {
            results.teamMembers = this.app.teamMembers.filter(member =>
                member.name.toLowerCase().includes(searchTerm) ||
                member.position.toLowerCase().includes(searchTerm) ||
                member.email.toLowerCase().includes(searchTerm)
            );
        }
        
        // Search tasks
        if (!filters.searchType || filters.searchType === 'all' || filters.searchType === 'tasks') {
            results.tasks = this.app.tasks.filter(task =>
                task.description.toLowerCase().includes(searchTerm)
            );
        }
        
        // Search roadmap items
        if (!filters.searchType || filters.searchType === 'all' || filters.searchType === 'roadmap') {
            if (this.app.roadmapManager) {
                results.roadmapItems = this.app.roadmapManager.roadmapItems.filter(item =>
                    item.title.toLowerCase().includes(searchTerm) ||
                    item.description.toLowerCase().includes(searchTerm)
                );
            }
        }
        
        return results;
    }

    matchesDateRange(dateString, dateRange) {
        if (!dateRange) return true;
        
        const date = new Date(dateString);
        const now = new Date();
        
        switch (dateRange) {
            case 'last7days':
                return date >= new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            case 'last30days':
                return date >= new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
            case 'last90days':
                return date >= new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
            default:
                return true;
        }
    }

    // Dashboard Analytics
    generateDashboardMetrics() {
        const meetings = this.app.meetings;
        const tasks = this.app.tasks;
        const now = new Date();
        const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        
        return {
            totalMeetings: meetings.length,
            meetingsThisWeek: meetings.filter(m => new Date(m.date) >= weekAgo).length,
            completedMeetings: meetings.filter(m => m.completed).length,
            upcomingMeetings: meetings.filter(m => new Date(m.date) > now && !m.completed).length,
            
            totalTasks: tasks.length,
            completedTasks: tasks.filter(t => t.completed).length,
            overdueTasks: tasks.filter(t => 
                !t.completed && t.dueDate && new Date(t.dueDate) < now
            ).length,
            myTasks: tasks.filter(t => t.assigneeId === 'manager' && !t.completed).length,
            
            teamSize: this.app.teamMembers.length,
            activeTeamMembers: this.app.teamMembers.filter(tm => tm.status === 'active').length,
            
            engagementScore: this.calculateEngagementScore(meetings),
            completionRate: tasks.length > 0 ? Math.round((tasks.filter(t => t.completed).length / tasks.length) * 100) : 0
        };
    }
}